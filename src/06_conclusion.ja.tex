\chapter{結論と展望}
\label{chap:conclusion}
本論文では，Linux netfilter を統合し，BGP などの既存のルーティングプロトコルとの共存を実現する新しい SRv6 End ビヘイビア，End.AN.NF を提案した．
End.AN.NF は，SRv6 の内部のパケットに対して netfilter の 3 つのフックポイント prerouting，forward，postrouting を透過的に適用させることができる．
netfilter のフックポイントを透過する事により，netfilter を実装に利用して作成されたアプリケーションは，その実装を変更せずに SR-aware アプリケーションとして機能させることができる．
また，End.AN.NF はパケットをマークするために SID の \texttt{ARG} フィールドを活用する．
このアプローチにより，netfilter を内部実装に利用した SF アプリケーションは，パケットバッファ上のマークをマッチングさせることによる動的ななルール調整が可能となる．
論文では End.AN.NF を Linux カーネルに実装し，その性能を評価した．
評価の結果，提案手法の実装は，SRv6 インナーパケットに netfilter のルールを適用する方法である End.DT4 と H.Encaps の組み合わせと比較して，27\% 高いスループットと3.0マイクロ秒低いレイテンシを実現した．
さらに，End と End.AN.NF のスループットの差は 6\% 未満であり，End.AN.NF のオーバーヘッドは最も基本的な End の動作と比較して許容範囲内であることを示している．

本論文の課題として，End.AN.NF について本論文で議論したのはデータプレーンの範疇に収まっている点が挙げられる．
データプレーンとは，ネットワーク通信において，実際のユーザのパケットを処理して転送するメカニズムのことを指す．
データプレーンと対になる概念として，コントロールプレーンが存在する．
コントロールプレーンとは，ユーザパケットの通る経路やポリシーなどを制御する概念であり，BGP などのルーティングプロトコルがコントロールプレーンの要素の例である．
End.AN.NF は SRv6 End ビヘイビアとして設計されているため，その SID を経路情報として広告することができる．
ただし，本論文では具体的なコントロールプレーンの設計を提案して議論することはできていない．

例えば，ある netfilter-based アプリケーションを SF 利用するために End.AN.NF と組み合わせるとき，アプリケーションが想定しているパケットバッファのマークを具体的なルールと結びつけて他のノードに伝える手法は現状議論できていない．
1 つのアイデアとしては，SDN 的な仕組みを使って SF アプリケーションの持つルールセットから経路情報を生成し，それをルートリフレクタを利用して iBGP で広告する手法が挙げられる．
しかし，この手法では SF アプリケーションごとに別な SDN コントローラの実装が必要であり，End.AN.NF の提供する netfilter-based アプリケーションの実装を変更することなく利用可能，という利点を活かすことができない．
今後は本研究を発展させてコントロールプレーンについても議論を行い，Linux と SRv6 による SFC の有用性について更に模索して行きたい．