\chapter{序論}
\label{chap:introduction}
\section{本研究の概要}
\label{section:background}
Service Function Chaining (SFC) は，Software Defined Network (SDN) 及び Network Function Virtualization (NFV) の文脈で研究されているトピックである~\cite{nfv,sfc-on-sdn-nfv-servey,sfc-on-sdn-scenario,imple-sfc-with-openflow}．
SFC では，サービスファンクション (SF) を通過する順序や SF のタイプに関する情報を事前に定義し，それらのルールをネットワーク機器に配布する必要がある．
SFC ネットワークを構築するネットワーク機器は，事前に決定されたルールに従って受信したパケットを SF に導く．
パケットを NF へ導くためのルールは，SDN コントローラやルーティングプロトコルによってネットワーク機器に配布される．
ネットワーク機器は IP ルーティング上の最短経路に関係なく，配布された SFC ルールに従ってパケットを転送する次のホップを選択する必要がある．
また，パケットのヘッダにこれらのルールに合致させるための特別な情報を埋め込む手法が取られることもある．
SFC は，クラウドサービスプロバイダ (CSP)，アプリケーションサービスプロバイダ (ASP) 及びインターネットサービスプロバイダ (ISP) にとって，現在の静的な環境に代わる柔軟かつ経済的な選択肢を提供する~\cite{survey-on-sfc}．

SFC を実現可能な技術には，いくつかの候補が存在する．
例えば OpenFlow~\cite{openflow}，Network Service Header (NSH)~\cite{rfc8300}，MPLS~\cite{rfc8595}などである．
これらの技術はどれも，最短経路に関係なく，ルールに基づいて受信したパケットを意図した SF に導く，という要件を満たすことができる．
OpenFlow では，経路情報を管理する中央のコントローラが，実際にパケットを転送する OpenFlow スイッチに対して明示的にパケット転送ルールを設定する．
OpenFlow スイッチは，コントローラによって適切に管理されたルールに従い，パケットを意図した SF に転送する．
OpenFlow のもつこのアーキテクチャは，従来のルーティングプロトコルに基づかない柔軟な経路制御を可能にする．
NSH は Service Path Identifier (SPI) とService Index (SI) によって SF を識別する．
NSH ノードは，パケットに付与された NSH 内の SPI，SI に基づいてパケットを転送する．
NSH は，サービスプレーンと呼ばれる専用のオーバーレイネットワークを作成し，そのオーバレイネットワーク内でサービスを転送する．
このオーバレイネットワークを構築する，というアーキテクチャにより，NSH では基礎となるネットワークトポロジを変更することなくサービス転送を可能にする．
一方，MPLS では，直接 NSH を使用する代わりに，MPLS ラベルスタックを利用する．
このラベルスタックには，パケットが通過すべきノードの順序がホップバイホップで含まれている．
ラベルスタック内で表現されるノードはルータだけでなく，SF も含まれるため，そのラベルスタックに基づいてパケットを転送する事で SFC を実現できる．
このアプローチもまた，基礎となるネットワークトポロジを変更せずに SFC を実現するために必要な，最短経路によらないパケット転送を達成する．

Segment Routing (SR)，特に Segment Routing over IPv6 (SRv6) もまた，SFCを実装するために使用される技術の1つである．
SR では，リンク，ノード，サービスといったネットワーク内の各エンティティを\textbf{セグメント}として表現する．
SRv6 パケットのヘッダ (SRH) には，セグメントリストと呼ばれる，そのパケットが通過すべきセグメントの順序を示したリストが含まれている．
SRv6 では，セグメントを識別するための ID (SID) として，IPv6 アドレスを使用する．
言い換えれば，SRv6 は IPv6 ルーティングインフラをその基盤として利用し，SRH 内で定義された順序に従って，任意のセグメントを経由してパケットを転送する．
SRv6 は，SF が実行されるノードをセグメントとして表現し，SID を割り当て，任意の順序で SF を通過するようにパケットを転送することで SFC を実現する．

SRv6 では，SF を SID で表し，セグメントリストに基づいて適切にパケットを転送をすることで，SRv6 を基盤とした SFC ネットワークを実現できる．
しかし，SRv6 レイヤよりも上位にある SF の振る舞いと，基盤となる IPv6 ルーティングインフラをどのように統合するかは明確でない．
例えば，IPv4パケットのネットワークアドレストランスレータ (NAT) を SRv6 ネットワーク内の SF として考慮する場合を考える．
SRv6 ネットワーク内において，IPv4パケットは，SRv6 ヘッダ (SRH) を含む外部 IPv6 ヘッダでカプセル化される．
SF で動作する NAT の実装が SRv6 に対応していない場合，SR-Proxy~\cite{ietf-spring-sr-service-programming-08}が必要となり，ネットワーク構成や運用における複雑さが増加してしまう~\cite{draft-scexp}．
実装が内部パケットへの NAT と SRv6 に則した転送動作を同時に実行できる場合，それはレイヤバイオレーションとなる． 
Linux には，SERA~\cite{sera} という iptables を拡張したファイアウォールアプリケーションが存在する．
SERA は SRH でカプセル化されたパケットについて，カプセル化された内部パケットのヘッダ情報にマッチする iptables のフィルタールールを適用できる．
SRv6 での基本的な転送動作として，End と呼ばれる動作がある．
SERA は iptables を拡張することで，この End 動作を処理する機能も実装されている．
ただし，既にLinux カーネルには IPv6 ルーティング，及び SRv6 End 動作に関する処理が実装されている．
SERA は，Linux カーネルに実装されている SRv6 機能を使わずに，独自に改良した iptables アクションによって End 動作を処理する．
つまり，SERA は Linux カーネル内で統合されている IPv6 ルーティングインフラと SRv6 処理機能を使わずに，独自に拡張した iptables によって SRv6 とフィルタリングサービスとしての NF を統合している．

本論文では，既存の netfilter を内部実装に利用する SF アプリケーションの実装を変更することなく SRv6 対応 SF として扱えるようにする，End.AN.NF 提案する．
End.AN.NF は Linux netfilter を NF として扱えるようにしつつ，Linux に実装されている IPv6 ルーティングインフラを活用する．
End.AN.NF は受信した SRv6 内部パケットに対して，netfilter のフックポイントを透過的するように設計されている．
本論文では End.AN.NF を Linux カーネル上で実装し，スループットとレイテンシを評価した．
評価の結果，End.AN.NF は End.DT 4と H.Encaps の組み合わせによる SRv6 内部パケットへの netfilter 適用と比較し て27\% 高いスループットと 3.0 マイクロ秒低いレイテンシを実現した．
さらに，End.AN.NFのレイテンシは，End.DT4とH.Encapsの組み合わせよりも3.0マイクロ秒低い．
また，End.AN.NFのレイテンシはマイクロ秒解像度でEnd動作と同じである．

\section{本論文の目的と構成}
% Linuxルータを利用している管理者の負担を減らしつつ高性能なSFCを実現すること、ではないかと思う。おそらく、Linuxルータの管理者はnetfilterには慣れており、それをSFCで使えれえばありがたいと考えているはず。
本論文は，Linux ルータを利用している管理者の負担を減らしつつ，高性能で柔軟な SFC を実現することを目的としている．
Linux には netfilter という高機能なパケット操作フレームワークが実装されており，管理者が netfilter を内部実装に使っている iptables や nftables などのアプリケーションを使って FW などのサービスを行うことは一般的である．
また，Linux には SRv6 の機能が実装されている．
SRv6 は近年注目される新しい技術であり，新しい技術であるがゆえに SRv6 をサポートするベンダ機器は多くない．
Linux を使うことで，新たなベンダ機器を導入するコストを抑えながら SRv6 ネットワークを構築することができる．
本論文では，SRv6 ネットワークにおける SFC 環境で netfilter を利用可能にする方法を提案する．

本論文における以降の構成は次の通りである．
\ref*{chap:introduction}章では，本論文の概要及び構成を述べる．
\ref*{chap:prerequisite-knowledgement}章では，本論文を読むにあたって必要となる前提知識を説明する．
\ref*{chap:related_works}章では，本論文の背景と取り組む問題について説明し，提案手法の概要を述べる．
\ref*{chap:design_and_impl}章では，本論文の提案する新たな SRv6 End behavior である End.AN.NF についての設計や詳細な動作，及び実装について述べる．
\ref*{chap:evaluation}章では，本論文の提案する End.AN.NF の性能が実用的であるか，また Linux カーネルのメインラインに実装されている手法の組み合わせに比べてどれだけパフォーマンスが改善されたのかをスループット及びレイテンシの観点から評価する．
\ref*{chap:conclusion}章では，本論文における結論と今後の展望について述べる．